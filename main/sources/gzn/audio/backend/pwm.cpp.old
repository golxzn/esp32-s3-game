#include <array>
#include <cerrno>
#include <cassert>
#include <utility>
#include <cstring>
#include <algorithm>

#include <esp_log.h>
#include <gzn/pwm-audio.hpp>

#include <freertos/FreeRTOS.h>
#include <freertos/portmacro.h>
#include <freertos/ringbuf.h>
#include <freertos/semphr.h>
#include <freertos/queue.h>
#include <freertos/task.h>

#include "gzn/audio/backend/pwm.hpp"

#include "gzn/utils.hpp"
#include "gzn/audio/wav-format.hpp"

namespace gzn::audio {

namespace {

inline constexpr auto TAG{ "gzn::audio::pwm" };

inline constexpr uint32_t audio_core_id{ 0u };
inline constexpr auto     SAMPLE_RATE{ comp::audio::pwm::sample_rate::SR_8000_HZ };
inline constexpr int16_t  BPS{ 16 };
inline constexpr auto     DUTY{ LEDC_TIMER_10_BIT };
inline constexpr int32_t  VOLUME_0DB{   16 };

inline constexpr uint8_t    speaker_pin            {   41 };
inline constexpr uint32_t   ringbuffer_length      { 4096 };
inline constexpr BaseType_t stream_task_stack_depth{ 2048 };
inline constexpr BaseType_t stream_task_priority   {    1 };
inline constexpr BaseType_t sound_task_stack_depth { 2048 };
inline constexpr BaseType_t sound_task_priority    {    1 };
inline constexpr size_t     sample_batch_size      {  512 };
inline constexpr size_t     sample_size            { sizeof(int16_t) };


struct defer_semaphore_giver {
	SemaphoreHandle_t semaphore;

	constexpr explicit defer_semaphore_giver(SemaphoreHandle_t handle) noexcept
		: semaphore{ handle } {}

	defer_semaphore_giver(const defer_semaphore_giver &) = delete;
	defer_semaphore_giver &operator=(const defer_semaphore_giver &) = delete;

	[[gnu::always_inline]]
	inline ~defer_semaphore_giver() {
		xSemaphoreGive(semaphore);
	};
};

struct file_info {
	std::FILE        *file_descr{ nullptr };
	SemaphoreHandle_t file_guard{};
	size_t            content_offset{}; ///< if not 0, then it's looping file

	[[gnu::always_inline]]
	inline void close(const BaseType_t delay = portMAX_DELAY) {
		xSemaphoreTake(file_guard, delay);
		content_offset = 0;
		std::fclose(std::exchange(file_descr, nullptr));
		xSemaphoreGive(file_guard);
	}
};

using samples_batch = std::array<int16_t, sample_batch_size>;

struct sound_streaming_task_context {
	std::array<file_info,     max_sound_tracks> streams{};
	std::array<uint32_t,      max_sound_tracks> streams_volumes{};
	std::array<samples_batch, max_sound_tracks> batches{};
	std::array<size_t,        max_sound_tracks> batches_sizes{};
};

struct pwm_context {
	sound_streaming_task_context sound_streaming_context{};
	portMUX_TYPE                 file_guard_lock portMUX_INITIALIZER_UNLOCKED;
	TaskHandle_t                 sound_streaming_handle{};
	uint32_t                     tracks_bitset{};
	bool                         running{ true };

	[[gnu::always_inline]]
	inline auto can_add_track() const -> bool {
		return (tracks_bitset & sound_tracks_mask) != sound_tracks_mask;
	}

	[[gnu::always_inline]]
	inline auto is_track_booked(const size_t index) const -> bool {
		return static_cast<bool>(tracks_bitset & (1 << index));
	}

	[[gnu::always_inline]]
	inline void book_track(const size_t index) {
		tracks_bitset |= (1 << index);
	}

	[[gnu::always_inline]]
	inline void unbook_track(const size_t index) {
		tracks_bitset &= ~(1 << index);
	}

	[[gnu::always_inline]]
	inline auto get_available_track_id() const -> size_t {
		for (size_t i{}; i < max_sound_tracks; ++i) {
			if (!(tracks_bitset & (1 << i))) {
				return i;
			}
		}
		return max_sound_tracks;
	}
};

pwm_context *backend_ctx{};

[[gnu::always_inline]]
inline void sample2duty(const int16_t *values, uint16_t *output) noexcept {
	// 128 / 16 = 8

	constexpr uint32_t shift{};
	constexpr uint32_t normalize{ 0x7FFFu };
	static const int16_t norm[8]{
		0x7FFFu, 0x7FFFu, 0x7FFFu, 0x7FFFu,
		0x7FFFu, 0x7FFFu, 0x7FFFu, 0x7FFFu,
	};

	// 1. load values    -> q0
	// 2. load normalize -> q1
	// 3. vadd
	//  "ee.vadds.s16.st.incp q1, %[p], q4, q1, q3\n\r"
	asm volatile (R"asm(
		ee.vld.128.ip        q0, %[i], 0
		ee.vld.128.ip        q1, %[n], 0
		# ee.vadds.s16.st.incp q2, %[o], q2, q0, q1
		ee.vadds.s16         q0, q0, q1
		ee.srcq.128.st.incp qs0, qs1, %[o]
	)asm"
		:
		: [i]"r"(values), [n]"r"(norm), [o]"r"(output)
		: "memory"
	);
}

void IRAM_ATTR sound_streaming_task(void *user) {
	using namespace utils::literals;

	constexpr size_t main_match_id{ 0 };
	constexpr auto   file_guard_timeout{ 100 };

	size_t count;

	auto &ctx{ *reinterpret_cast<sound_streaming_task_context *>(user) };

	auto &batches_sizes{ ctx.batches_sizes };
	auto &batches{ ctx.batches };

	auto [ringbuf, crit]{ comp::audio::pwm::get_ringbuffer() };

	while (backend_ctx->running) {
		// STEP 0. Fetch data from files & manage their EOFs

		size_t last_batch_id{};
		size_t max_batch_size{};
		size_t active_batches_count{};
		for (size_t i{}; i < std::size(batches); ++i) {
			auto &stream{ ctx.streams[i] };

			if (stream.file_descr == nullptr) {
				batches_sizes[i] = 0;
				continue;
			}
			if (pdFALSE == xSemaphoreTake(stream.file_guard, file_guard_timeout)) {
				continue;
			}
			const defer_semaphore_giver defer{ stream.file_guard };

			last_batch_id = i;
			++active_batches_count;
			batches_sizes[i] = std::fread(
				std::data(batches[i]), sample_size,
				std::size(batches[i]), stream.file_descr
			);
			if (max_batch_size < batches_sizes[i]) {
				max_batch_size = batches_sizes[i];
			}

			if (!std::feof(stream.file_descr)) {
				continue;
			}

			if (0 != stream.content_offset
			&&  0 == std::fseek(stream.file_descr, stream.content_offset, SEEK_SET)
			) [[likely]] {
				continue;
			}

			std::fclose(std::exchange(stream.file_descr, nullptr));
		}

		if (max_batch_size == 0) {
			vTaskDelay(100_ms);
			continue;
		}

		// if (active_batches_count == 1) {
		// 	comp::audio::pwm::write(std::span{
		// 		std::data(batches[last_batch_id]),
		// 		max_batch_size
		// 	}, count, 100_ms);
		//
		// 	continue;
		// }


		// STEP 1. Merge batches into output one
		constexpr uint32_t shift{ BPS / DUTY };
		constexpr uint32_t normalize{ 0x7FFFu };
		// portENTER_CRITICAL(crit);

		// void *item;
		// const auto result{ xRingbufferSendAcquire(
		// 	ringbuf, &item, max_batch_size * sizeof(int16_t), 100_ms
		// ) };
		// if (result == pdFALSE) {
		// 	portEXIT_CRITICAL(crit);
		// 	continue;
		// }

		// auto data{ reinterpret_cast<uint16_t *>(item) };
		uint8_t data[2];
		for (size_t i{}; i < max_batch_size; ++i) {
			int16_t mixed_sample{};
			for (size_t batch_id{}; batch_id < std::size(batches); ++batch_id) {
				if (i >= batches_sizes[batch_id]) {
					continue;
				}

				mixed_sample += (batches[batch_id][i] / active_batches_count)
					// * ctx.streams_volumes[batch_id]
				;
			}

			// data[i] = static_cast<uint16_t>((mixed_sample + normalize) >> shift);
			const auto value{ static_cast<uint16_t>((mixed_sample + normalize) >> shift) };
			data[0] = static_cast<uint8_t>(value);
			data[1] = static_cast<uint8_t>(value >> 8);
			xRingbufferSend(ringbuf, data, sizeof(value), 10);

		}

		// xRingbufferSendComplete(ringbuf, item);

		// portEXIT_CRITICAL(crit);

		// STEP 2. Send batch to player task
		//
		// comp::audio::pwm::write(
		// 	std::span{ std::data(batches[last_batch_id]), max_batch_size },
		// 	count, 100_ms
		// );
	}
}

} // namespace

auto pwm::startup() -> startup_result {
	using namespace gzn::utils::literals;

	if (backend_ctx) {
		ESP_LOGE(TAG, "Audio backend is already up!");
		return startup_result::already_started;
	}

	auto backend_storage{ heap_caps_malloc( sizeof(pwm_context), MALLOC_CAP_8BIT) };

	backend_ctx = new (backend_storage) pwm_context{};
	if (!backend_ctx) {
		ESP_LOGE(TAG, "Cannot allocate backend context!");
		return startup_result::not_enough_memory;
	}

	using namespace comp::audio::pwm;
	const config_t config{
		.channels{
			channel_info{ .gpio_num{ speaker_pin }, .channel{ LEDC_CHANNEL_0 } },
			channel_info{ .gpio_num{ speaker_pin }, .channel{ LEDC_CHANNEL_1 } },
		},
		.duty_resolution    = DUTY,
		.ringbuf_len        = ringbuffer_length
	};
	ESP_ERROR_CHECK(init(config));

	ESP_ERROR_CHECK(set_param(SAMPLE_RATE, comp::audio::pwm::MAX_CHANNELS_COUNT));
	ESP_ERROR_CHECK(start());


	for (auto &info : backend_ctx->sound_streaming_context.streams) {
		portENTER_CRITICAL(&backend_ctx->file_guard_lock);
		if (info.file_guard = xSemaphoreCreateMutex(); !info.file_guard) {
			ESP_LOGE(TAG, "Failed to create file guard!");
		}
		portEXIT_CRITICAL(&backend_ctx->file_guard_lock);
	}

	const auto status{ xTaskCreatePinnedToCore(
		sound_streaming_task, "sound_streaming_task",
		sound_task_stack_depth, &backend_ctx->sound_streaming_context,
		sound_task_priority, &backend_ctx->sound_streaming_handle,
		audio_core_id
	) };
	if (status != pdPASS) {
		shutdown();
		return startup_result::cannot_create_task;
	}

	return startup_result::ok;
}

void pwm::shutdown() {
	using namespace gzn::utils::literals;

	backend_ctx->running = false;

	for (auto &info : backend_ctx->sound_streaming_context.streams) {
		if (info.file_descr) {
			info.close(1000_ms);
		}
	}

	vTaskDelay(100_ms);

	for (auto &info : backend_ctx->sound_streaming_context.streams) {
		portENTER_CRITICAL(&backend_ctx->file_guard_lock);
		vSemaphoreDelete(info.file_guard);
		portEXIT_CRITICAL(&backend_ctx->file_guard_lock);
	}

	vTaskDelete(backend_ctx->sound_streaming_handle);

	comp::audio::pwm::stop();
	comp::audio::pwm::deinit();

	heap_caps_free(std::exchange(backend_ctx, nullptr));
}

void pwm::update() {
	const auto &streams{ backend_ctx->sound_streaming_context.streams };
	for (size_t i{}; i < std::size(streams); ++i) {
		if (streams[i].file_descr == nullptr) {
			backend_ctx->unbook_track(i);
		}
	}
}

auto pwm::load(const track_info &info) -> track_id {
	if (!backend_ctx->can_add_track()) [[unlikely]] {
		ESP_LOGW(TAG, R"(No available space to load "%.*s" sound)",
			static_cast<int>(std::size(info.filename)), std::data(info.filename)
		);
		return invalid_tack_id;
	}

	using namespace utils::literals;
	constexpr auto file_guard_timeout{ 50_ms };

	static std::array<uint8_t, sizeof(wav::header)> header_data{};
	auto &ctx{ backend_ctx->sound_streaming_context };
	while (backend_ctx->can_add_track()) {
		const auto id{ backend_ctx->get_available_track_id() };
		auto &stream{ ctx.streams[id] };

		if (pdFALSE == xSemaphoreTake(stream.file_guard, file_guard_timeout)) {
			continue;
		}

		const defer_semaphore_giver defer{ stream.file_guard };

		if (stream.file_descr) [[unlikely]] {
			backend_ctx->book_track(id);
			continue;
		}

		stream.file_descr = std::fopen(std::data(info.filename), "rb");
		if (!stream.file_descr) [[unlikely]] {
			ESP_LOGW(TAG, R"(Cannot open "%.*s" audio file: %s)",
				static_cast<int>(std::size(info.filename)),
				std::data(info.filename), std::strerror(errno)
			);
			break;
		}

		const auto read{ std::fread(
			std::data(header_data), sizeof(uint8_t), std::size(header_data),
			stream.file_descr
		) };
		if (read < std::size(header_data)) [[unlikely]] {
			std::fclose(std::exchange(stream.file_descr, nullptr));
			ESP_LOGW(TAG, R"(File size of "%.*s" is less than WAV file header)",
				static_cast<int>(std::size(info.filename)),
				std::data(info.filename)
			);
			break;
		}

		const auto header{ wav::header::make_view(header_data) };
		header->dump();

		if (BPS != header->format.bits_per_sample) [[unlikely]] {
			std::fclose(std::exchange(stream.file_descr, nullptr));
			ESP_LOGE(TAG, "Sound has %zu BPS, but %zu required.",
				header->format.bits_per_sample, BPS
			);
			break;
		}

		ctx.streams_volumes[id] = std::clamp(
			static_cast<int32_t>(info.volume), -VOLUME_0DB, VOLUME_0DB
		) + VOLUME_0DB / VOLUME_0DB;

		if (info.loop) {
			stream.content_offset = read + 1;
		}

		backend_ctx->book_track(id);
		return id;
	}

	return invalid_tack_id;
}

auto pwm::unload(const track_id track) -> bool {
	if (!backend_ctx->is_track_booked(track)) {
		ESP_LOGW(TAG, "Failed to unload %zu track. Not found", track);
		return false;
	}

	auto &stream{ backend_ctx->sound_streaming_context.streams[track] };
	if (stream.file_descr != nullptr) {
		stream.close();
	}

	backend_ctx->unbook_track(track);
	return true;
}

void pwm::unload_all() {
	for (track_id track{}; track < max_sound_tracks; ++track) {
		unload(track);
	}
}

auto pwm::is_busy(const track_id track) -> bool {
	return backend_ctx->is_track_booked(track);
}


} // namespace gzn::audio

